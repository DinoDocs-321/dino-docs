// generator.jsx

import './generator.css';
import React, { useState, useEffect, useReducer } from 'react';
import axios from 'axios';

// Unique ID generator
let uniqueId = 0;
function getUniqueId() {
    return ++uniqueId;
}

function Generator() {
    // State variables for schema details
    const [schemaTitle, setSchemaTitle] = useState('');
    const [schemaDescription, setSchemaDescription] = useState('');
    const [format, setFormat] = useState('json');
    const [numSamples, setNumSamples] = useState(10);
    const [response, setResponse] = useState(null);

    // State variable for data types
    const [dataTypes, setDataTypes] = useState([]);

    // State variable for form validation errors
    const [errors, setErrors] = useState([]);

    // Fetch data types from the API when the component mounts
    useEffect(function() {
        async function fetchDataTypes() {
            try {
                const response = await axios.get('http://127.0.0.1:8000/api/data-types/');
                setDataTypes(response.data);
            } catch (error) {
                console.error('Error fetching data types:', error);
            }
        }
        fetchDataTypes();
    }, []);

    // Reducer for managing fields
    function fieldsReducer(state, action) {
        switch (action.type) {
            case 'ADD_FIELD':
                return [
                    ...state,
                    {
                        id: getUniqueId(),
                        keyTitle: '',
                        dataType: '',
                        description: '',
                        attributes: {},
                        properties: [],
                        items: null,
                    },
                ];
            case 'REMOVE_FIELD':
                return state.filter(field => field.id !== action.fieldId);
            case 'UPDATE_FIELD':
                return state.map(field => updateField(field, action));
            default:
                return state;
        }
    }

    function updateField(field, action) {
        if (field.id === action.fieldId) {
            return { ...field, [action.key]: action.value };
        } else {
            let updatedField = field;
            if (field.properties && field.properties.length > 0) {
                updatedField = {
                    ...field,
                    properties: field.properties.map(prop => updateField(prop, action)),
                };
            }
            if (field.items) {
                updatedField = {
                    ...field,
                    items: updateField(field.items, action),
                };
            }
            return updatedField;
        }
    }

    const [fields, dispatch] = useReducer(fieldsReducer, []);

    // Function to handle form submission
    async function handleSubmit(event) {
        event.preventDefault();

        // Validate fields
        const validationErrors = [];
        validateFields(fields, validationErrors);

        if (validationErrors.length > 0) {
            setErrors(validationErrors);
            return;
        } else {
            setErrors([]);
        }

        // Build the schema from the fields state
        const schemaData = {
            $schema: 'http://json-schema.org/draft-07/schema#',
            type: 'object',
            title: schemaTitle || 'Generated Schema',
            description: schemaDescription || 'This schema was generated by the user',
            properties: buildProperties(fields),
        };

        console.log('Generated Schema Data:', JSON.stringify(schemaData, null, 2));

        const dataToSend = {
            schema: schemaData,
            format: format,
            num_samples: numSamples,
        };

        console.log('Sending data:', dataToSend);

        try {
            const result = await axios.post('http://127.0.0.1:8000/api/generate-documents/', dataToSend, {
                headers: {
                    'Content-Type': 'application/json',
                },
            });

            console.log('Response from server:', result.data);
            setResponse(result.data);
        } catch (error) {
            console.error('There was an error generating the documents!', error);
        }
    }

    // Function to validate fields recursively
    function validateFields(fields, errors, parentKey = '') {
        fields.forEach(field => {
            const fieldPath = parentKey ? `${parentKey} > ${field.keyTitle || 'Unnamed Field'}` : field.keyTitle || 'Unnamed Field';
            if (!field.keyTitle) {
                errors.push(`Key Title is required for field "${fieldPath}".`);
            }
            if (!field.dataType) {
                errors.push(`Data Type is required for field "${fieldPath}".`);
            }
            if (field.dataType === 'object' && field.properties) {
                validateFields(field.properties, errors, fieldPath);
            }
            if (field.dataType === 'array' && field.items) {
                validateFields([field.items], errors, fieldPath);
            }
        });
    }

    // Function to build properties recursively
    function buildProperties(fields) {
        const properties = {};
        fields.forEach(field => {
            if (field.keyTitle && field.dataType) {
                properties[field.keyTitle] = processField(field);
            }
        });
        return properties;
    }

    function processField(field) {
        const dataTypeInfo = mapDataType(field.dataType);
        if (!dataTypeInfo) {
            console.warn(`Data type "${field.dataType}" not found.`);
            return {};
        }

        const schemaField = {
            type: dataTypeInfo.type,
            description: field.description || '',
        };

        if (dataTypeInfo.format) {
            schemaField.format = dataTypeInfo.format;
        }

        // Include additional attributes
        for (const [attr, value] of Object.entries(field.attributes || {})) {
            if (value !== '') {
                if (['minLength', 'maxLength', 'minimum', 'maximum'].includes(attr)) {
                    schemaField[attr] = parseInt(value, 10);
                } else {
                    schemaField[attr] = value;
                }
            }
        }

        if (dataTypeInfo.type === 'object' && field.properties && field.properties.length > 0) {
            schemaField.properties = buildProperties(field.properties);
        }

        if (dataTypeInfo.type === 'array' && field.items) {
            schemaField.items = processField(field.items);
        }

        return schemaField;
    }

    // Function to map data type value to its info
    function mapDataType(value) {
        var foundType = dataTypes.find(function(dataType) {
            return dataType.value === value;
        });
        return foundType || null;
    }

    // Main component render
    return (
        <div>
            <h1>Data Generator</h1>
            <div className="schema-info">
                <input
                    type="text"
                    placeholder="Schema Title"
                    value={schemaTitle}
                    onChange={function(e) {
                        setSchemaTitle(e.target.value);
                    }}
                />
                <input
                    type="text"
                    placeholder="Schema Description"
                    value={schemaDescription}
                    onChange={function(e) {
                        setSchemaDescription(e.target.value);
                    }}
                />
            </div>
            {errors.length > 0 && (
                <div className="errors">
                    <h3>Form Errors:</h3>
                    <ul>
                        {errors.map((error, index) => (
                            <li key={index} style={{ color: 'red' }}>
                                {error}
                            </li>
                        ))}
                    </ul>
                </div>
            )}
            <div className="fields-container">
                {fields.map(field => (
                    <Field
                        key={field.id}
                        field={field}
                        dataTypes={dataTypes}
                        dispatch={dispatch}
                        onRemove={() => dispatch({ type: 'REMOVE_FIELD', fieldId: field.id })}
                    />
                ))}
            </div>
            <button type="button" onClick={() => dispatch({ type: 'ADD_FIELD' })}>
                Add Property
            </button>
            <button type="button" onClick={handleSubmit}>Submit</button>
            {response && (
                <div className="response">
                    <h3>Response from Server:</h3>
                    <pre>{JSON.stringify(response, null, 2)}</pre>
                </div>
            )}
        </div>
    );
}

// Field component
function Field(props) {
    const { field, dataTypes, dispatch, onRemove } = props;

    const handleChange = (key, value) => {
        dispatch({ type: 'UPDATE_FIELD', fieldId: field.id, key, value });
    };

    const addNestedField = () => {
        const newField = {
            id: getUniqueId(),
            keyTitle: '',
            dataType: '',
            description: '',
            attributes: {},
            properties: [],
            items: null,
        };
        dispatch({
            type: 'UPDATE_FIELD',
            fieldId: field.id,
            key: 'properties',
            value: [...(field.properties || []), newField],
        });
    };

    const removeNestedField = (nestedFieldId) => {
        dispatch({
            type: 'UPDATE_FIELD',
            fieldId: field.id,
            key: 'properties',
            value: field.properties.filter(f => f.id !== nestedFieldId),
        });
    };

    const addArrayItem = () => {
        const newItem = {
            id: getUniqueId(),
            keyTitle: '',
            dataType: '',
            description: '',
            attributes: {},
            properties: [],
            items: null,
        };
        dispatch({
            type: 'UPDATE_FIELD',
            fieldId: field.id,
            key: 'items',
            value: newItem,
        });
    };

    const removeArrayItem = () => {
        dispatch({
            type: 'UPDATE_FIELD',
            fieldId: field.id,
            key: 'items',
            value: null,
        });
    };

    return (
        <div className="field" style={{ marginLeft: '20px', borderLeft: '1px solid #ccc', paddingLeft: '10px' }}>
            <select value={field.dataType} onChange={e => handleChange('dataType', e.target.value)}>
                <option value="">Select Data Type</option>
                {dataTypes.map(type => (
                    <option key={type.value} value={type.value}>
                        {type.label}
                    </option>
                ))}
            </select>
            <input
                type="text"
                placeholder="Key Title"
                value={field.keyTitle}
                onChange={e => handleChange('keyTitle', e.target.value)}
            />
            <input
                type="text"
                placeholder="Description"
                value={field.description}
                onChange={e => handleChange('description', e.target.value)}
            />

            {/* Handle nested objects */}
            {field.dataType === 'object' && (
                <div style={{ marginTop: '10px' }}>
                    <button type="button" onClick={addNestedField}>
                        Add Nested Property
                    </button>
                    {field.properties && field.properties.map(propField => (
                        <Field
                            key={propField.id}
                            field={propField}
                            dataTypes={dataTypes}
                            dispatch={dispatch}
                            onRemove={() => removeNestedField(propField.id)}
                        />
                    ))}
                </div>
            )}

            {/* Handle arrays */}
            {field.dataType === 'array' && (
                <div style={{ marginTop: '10px' }}>
                    <h4>Array Items:</h4>
                    {field.items ? (
                        <Field
                            field={field.items}
                            dataTypes={dataTypes}
                            dispatch={dispatch}
                            onRemove={removeArrayItem}
                        />
                    ) : (
                        <button type="button" onClick={addArrayItem}>
                            Add Array Item
                        </button>
                    )}
                </div>
            )}

            <button type="button" onClick={onRemove}>
                Remove
            </button>
        </div>
    );
}

export default Generator;
