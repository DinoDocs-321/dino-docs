// generator.jsx
import './generator.css';
import React, { useState, useEffect } from 'react';
import axios from 'axios';

const Generator = () => {
    const [schemaTitle, setSchemaTitle] = useState(''); // For schema title
    const [schemaDescription, setSchemaDescription] = useState(''); // For schema description
    const [format, setFormat] = useState('json'); // Just generate JSON
    const [numSamples, setNumSamples] = useState(10);
    const [response, setResponse] = useState(null);
    const [dataTypes, setDataTypes] = useState([]); // Store data types

    // Fetch data types from the API when the component mounts
    useEffect(() => {
        const fetchDataTypes = async () => {
            try {
                const result = await axios.get('http://127.0.0.1:8000/api/data-types/');
                setDataTypes(result.data);
            } catch (error) {
                console.error('Error fetching data types:', error);
            }
        };
        fetchDataTypes();
    }, []);

    // Initial state: an array of fields
    const [fields, setFields] = useState([]);

    // Function to add a new field
    const addField = (parentField) => {
        const newField = {
            id: Date.now() + Math.random(),
            keyTitle: '',
            dataType: '',
            description: '',
            attributes: {}, // For minLength, maxLength, etc.
            properties: [], // For object type
            items: null, // For array type
        };

        if (parentField) {
            parentField.properties.push(newField);
            setFields([...fields]);
        } else {
            setFields([...fields, newField]);
        }
    };

    // Function to remove a field
    const removeField = (fieldToRemove, parentField) => {
        if (parentField) {
            parentField.properties = parentField.properties.filter(f => f.id !== fieldToRemove.id);
            setFields([...fields]);
        } else {
            setFields(fields.filter(f => f.id !== fieldToRemove.id));
        }
    };

    // Function to update a field's value
    const updateField = (field, key, value) => {
        field[key] = value;

        // If dataType changes, reset properties or items
        if (key === 'dataType') {
            if (value === 'object') {
                field.properties = field.properties || [];
                field.items = null;
            } else if (value === 'array') {
                field.items = field.items || {
                    id: Date.now() + Math.random(),
                    keyTitle: '',
                    dataType: '',
                    description: '',
                    attributes: {},
                    properties: [],
                    items: null,
                };
                field.properties = [];
            } else {
                field.properties = [];
                field.items = null;
            }
        }

        setFields([...fields]);
    };

    // Function to build the schema recursively
    const buildSchema = (fields) => {
        const properties = {};
        const required = [];

        fields.forEach(field => {
            if (field.keyTitle) {
                required.push(field.keyTitle);
                properties[field.keyTitle] = processField(field);
            }
        });

        const schema = {
            "$schema": "http://json-schema.org/draft-07/schema#",
            "type": "object",
            "title": schemaTitle || "Generated Schema",
            "description": schemaDescription || "This schema was generated by the user",
            "properties": properties,
            "required": required,
        };

        return JSON.stringify(schema, null, 2);
    };

    const processField = (field) => {
        const schemaField = {
            type: field.dataType,
            description: field.description || '',
        };

        // Include additional attributes
        const attributes = field.attributes;
        for (const [attr, value] of Object.entries(attributes)) {
            if (value !== '') {
                if (['minLength', 'maxLength', 'minimum', 'maximum'].includes(attr)) {
                    schemaField[attr] = parseInt(value, 10);
                } else {
                    schemaField[attr] = value;
                }
            }
        }

        if (field.dataType === 'object') {
            const props = {};
            const req = [];
            field.properties.forEach(childField => {
                if (childField.keyTitle) {
                    req.push(childField.keyTitle);
                    props[childField.keyTitle] = processField(childField);
                }
            });
            schemaField.properties = props;
            schemaField.required = req;
        } else if (field.dataType === 'array' && field.items) {
            schemaField.items = processField(field.items);
        }

        return schemaField;
    };

    // Function to handle the form submission and send data to the backend
    const handleSubmit = async (event) => {
        event.preventDefault();

        // Generate JSON schema before submitting
        const schema = buildSchema(fields);

        // Prepare the data to send to the backend
        const dataToSend = {
            schema: JSON.parse(schema),  // Pass the generated schema as an object
            format,  // e.g., 'json'
            num_samples: numSamples,  // Number of samples
        };

        console.log('Sending data:', dataToSend);  // Optional: Log data to ensure correctness

        try {
            const result = await axios.post('http://127.0.0.1:8000/api/generate-data/', dataToSend, {
                headers: {
                    'Content-Type': 'application/json'  // Ensure the content type is JSON
                }
            });

            // Handle the response from the server
            console.log('Response from server:', result.data);
            setResponse(result.data);  // Store the response data
        } catch (error) {
            // Handle any errors during the request
            console.error('There was an error generating the documents!', error);
        }
    };

    // Recursive component to render a field
    const Field = ({ field, parentField }) => {
        return (
            <div className="field">
                <select value={field.dataType} onChange={(e) => updateField(field, 'dataType', e.target.value)}>
                    <option value="">Select Data Type</option>
                    {dataTypes.map((type) => (
                        <option key={type.value} value={type.value}>{type.label}</option>
                    ))}
                </select>
                <input
                    type="text"
                    placeholder="Key Title"
                    value={field.keyTitle}
                    onChange={(e) => updateField(field, 'keyTitle', e.target.value)}
                />
                <input
                    type="text"
                    placeholder="Description"
                    value={field.description}
                    onChange={(e) => updateField(field, 'description', e.target.value)}
                />

                {/* Additional attributes inputs */}
                {field.dataType === 'string' && (
                    <>
                        <input
                            type="number"
                            placeholder="Min Length"
                            value={field.attributes.minLength || ''}
                            onChange={(e) => {
                                field.attributes.minLength = e.target.value;
                                setFields([...fields]);
                            }}
                        />
                        <input
                            type="number"
                            placeholder="Max Length"
                            value={field.attributes.maxLength || ''}
                            onChange={(e) => {
                                field.attributes.maxLength = e.target.value;
                                setFields([...fields]);
                            }}
                        />
                        <input
                            type="text"
                            placeholder="Pattern"
                            value={field.attributes.pattern || ''}
                            onChange={(e) => {
                                field.attributes.pattern = e.target.value;
                                setFields([...fields]);
                            }}
                        />
                        <input
                            type="text"
                            placeholder="Format"
                            value={field.attributes.format || ''}
                            onChange={(e) => {
                                field.attributes.format = e.target.value;
                                setFields([...fields]);
                            }}
                        />
                    </>
                )}
                {(field.dataType === 'integer' || field.dataType === 'number') && (
                    <>
                        <input
                            type="number"
                            placeholder="Minimum"
                            value={field.attributes.minimum || ''}
                            onChange={(e) => {
                                field.attributes.minimum = e.target.value;
                                setFields([...fields]);
                            }}
                        />
                        <input
                            type="number"
                            placeholder="Maximum"
                            value={field.attributes.maximum || ''}
                            onChange={(e) => {
                                field.attributes.maximum = e.target.value;
                                setFields([...fields]);
                            }}
                        />
                    </>
                )}
                {field.dataType === 'object' && (
                    <>
                        <button type="button" onClick={() => addField(field)}>Add Nested Property</button>
                        {field.properties.map((childField) => (
                            <div key={childField.id} className="nested-field">
                                <Field field={childField} parentField={field} />
                            </div>
                        ))}
                    </>
                )}
                {field.dataType === 'array' && field.items && (
                    <>
                        <h4>Array Items:</h4>
                        <Field field={field.items} parentField={field} />
                    </>
                )}
                <button type="button" onClick={() => removeField(field, parentField)}>Remove</button>
            </div>
        );
    };

    return (
        <div>
            <h1>Data Generator</h1>
            <div className="schema-info">
                <input
                    type="text"
                    placeholder="Schema Title"
                    value={schemaTitle}
                    onChange={(e) => setSchemaTitle(e.target.value)}
                />
                <input
                    type="text"
                    placeholder="Schema Description"
                    value={schemaDescription}
                    onChange={(e) => setSchemaDescription(e.target.value)}
                />
            </div>
            <div className="fields-container">
                {fields.map((field) => (
                    <Field key={field.id} field={field} parentField={null} />
                ))}
            </div>
            <button type="button" onClick={() => addField(null)}>Add Property</button>
            <button type="button" onClick={handleSubmit}>Submit</button>
            {response && (
                <div className="response">
                    <h3>Response from Server:</h3>
                    <pre>{JSON.stringify(response, null, 2)}</pre>
                </div>
            )}
        </div>
    );
};

export default Generator;
